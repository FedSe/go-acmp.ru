# Решения задач [acmp](https://acmp.ru/)

С адским, экстремальным сокращением во имя "лучших решений" на Go.

В качестве критерия ранжирования лучших попыток служит размер кода закачиваемой программы. При подсчете размера кода используется следующая формула:

> [Размер кода] = max([длина кода без пробелов, табуляций и символов перевода строки], [полная длина кода, делённая нацело на 4])

# Code golfing на Go по версии ACMP:

## Ограничения


- пакет обязательно называется **main**, т.к. является исполняемой программой
  
- ... поэтому основная функция тоже **main**, ведь это точка старта

- built-in функция **print()** вызывает *Presentation error*. Для чтения и записи возможно использовать пакеты **fmt** и **bufio**

Учитывая вышесказанное, самая короткая программа, которую возможно написать, выглядит следующим образом:

```go
package main
import . "fmt"
func main(){
	Print(1)
}

// 43 символа
```


Текущая версия Go **1.20.14**

С точки зрения сокращений кода, это означает отсутствие:

- built-in функций максимума/минимума -> **max()**, **min()**
- range по числу, доступны только перечисляемые типы -> **for i := range 5 {}**
- полезных функций **slices** -> **Delete()**, **Insert()**, **Clone(s)**
- для **strings** отсутствует раздел строки на первую часть и остаток -> **cut()**
- ... ну и так далее, ситуативно.

## Правила

### Импорт

Импорт точечный, насколько возможно.
```go
/* ПЛОХО */
package main
import "fmt"
func main(){
	fmt.Print(1)
}

/* Хорошо */
package main
import . "fmt"
func main(){
	Print(1)
}
```
В случае golf практик это практически всегда реализуемо. Исключения:

1. совместное использование **bufio** и **fmt** - попытка такого импорта вызовет сообщение *Scanner redeclared in this block* и не скомпилируется.
2. совместное использование **strings** и **unicode** - попытка такого импорта вызовет вообще кучу сообщений - *Title, ToLower, ToTitle, ToUpper redeclared in this block*.
3. использование **reflect** через . - попытка такого импорта вызовет сообщение *Append redeclared in this block*, т.е. такой импорт принципиально невозможен.

В таком случае рекомендуется импорт с односимвольным псевдонимом.
```go
package main
import (
	b "bufio"
	. "fmt"
	. "os"
)
func main() {
	n := 0
	Fscan(b.NewReader(Stdin), &n)
	Print(n)
}
```

Пример выше демонстрирует ещё несколько очевидных правил - множественный импорт обязательно группированный (одним оператором) и с переносом строк вместо **;**

### Объявление переменных

Краткое определение **:=** выгодно часто, но не всегда. В ситуации однократного определения переменной наиболее выгодные практики таковы:

```go
myInt := 0      // int (max = int64)
myString := ""  // string
myRune := ' '   // rune
myBool := 1 > 0 // bool
myFloat := 0.   // float64
```

Но если требуется определить несколько переменных одного типа - можно считать длину с **var**. Наиболее показателен пример для int:

```go
/*11 символов*/
var a, b, c int

/*12 символов*/
a := 0
b := 0
c := 0
```
При увеличении количества требуемых **int** разрыв будет увеличиваться. Подобные вычисления запрета на использование моржи по выгоде при объявлении N переменных для всех типов следующие:

|   Тип   |    :=    |   var    | N |
|---------|----------|----------|---|
| int     |    12    |    11    | 3 |
| string  |    17    |    16    | 4 |
| float64 |    17    |    17    | 4* |
|   bool  |    10    |    10    | 2* |
|   rune  |    13    |    12    | 3**|
|   byte  |    10    |    8     | 1  |

	* В ситуации равенства символов лучше начать использовать var
	** Имейте в виду, что rune := ' ' это значение 32, а var rune это 0

Можно также объявить некоторые функции как переменные, содержащие ссылку на функцию (функциональное значение). Это полезно в ситуации многократного их вызова в различных участках кода или для различных данных.
```go
P := Print
P(123)	//	fmt.Print(123)

S := Scan
S(&n)	//	fmt.Scan(&n)

S := Fscan
S(s, &n)	//	fmt.Fscan(s, &n)

var b Builder
W := b.WriteByte
W(48)	//	b.WriteByte(48)

N := NewInt
a := N(1)	//	a := big.NewInt(1)

I := Index
a := I(str, sub)	// a := strings.Index(str, sub)

import (
	. "strings"
	u "unicode"
)
L = ToLower	// strings.ToLower
U = u.ToUpper	// unicode.ToUpper
```

### Строки

По-хорошему, "\n" в коде вообще быть не должно. Исключением здесь может быть разве что строка формата:

```go
r.ReadString('\n') // \n здесь это руна
```
Чем менять? Либо **ln**, либо raw **string literal**
```go
/*ln*/
Scanf("%d\n",&a)

Scanln(&a)

/*raw string literal*/
Printf("Число 1: %d\nЧисло 2: %d", a, b)

Printf(`Число 1: %d
Число 2: %d`, a, b) //В данном случае перенос строки учтён
```

### Карты

1. Используйте пустые интерфейсы через **any** в ключе, когда он не **int**.
2. При объявлении элементов внутри слайса, карты или иных структур, после последнего элемента запятая убирается.
```go
/*ПЛОХО*/
t := map[float64]string{
	12.5: "GREEN",
	12.9: "RED",
}

/*Хорошо*/
t := map[any]string{
	12.5: "GREEN",
	12.9: "RED"}
```
3. Нет ситуаций, когда **make** выгоден для **map**. Не используйте его.
```go
/*ПЛОХО*/
var h = make(map[any]int)
h := make(map[any]int)
var v = make(map[any][]string)

/*Хорошо*/
var h = map[any]int{}
h := map[any]int{}
var v = map[any][]string{}
```
4. Поиск по карте, если без булевой о ненаходе никак - только с переносом строки во избежание ;
```go
if v, o := m[x]
o {
	return v
}
```

### Switch-case

Выгоден для множественных сравнений с единым результатом:
```go
/*28 символов*/
if x == f || x == -f || y == f || y == -f { ... }

/*23 символа*/
switch f {
	case x, -x, y, -y: ...
}
```

### math/big

Всегда стоит смотреть на сигнатуры функций *math/big*. Это позволяет делать сложные однострочные конструкции. При выборе способа инициализации структуры следует исходить их дальнейшего применения. Технически есть два варианта - указатель или структура, но фактически только структура, и вот почему:

#### u - Указатель на структуру, *big.Int
```go
/* u is *big.Int */
u := new(Int)	// 11 - плохо
u := &Int{}		//  9 - возможно
u := NewInt(0)	// 12 - возможно
var u *Int		//  8 - бессмысленно(не инициализировано)
```
Использование:
```go
/* вы не можете сделать новый *Int на основе текущего */
u := NewInt(0)
u2 := u			// Это не работает так
u2 := NewInt(0)	// Это работает так

/* вы не можете напрямую прочитать такое значение Scan */
var u *Int
Scan(&u)

/* вы передаёте такие переменные как есть */
var u, v *Int
v = NewInt(999)
u = NewInt(999)
u.Div(u, v)
```
#### u - Структура, big.Int
```go
/* v is big.Int */
v := Int{}		// 8 - плохо
var v Int		// 7 - хорошо
```
Использование:
```go
/* вы можете сделать новый *Int на основе текущего */
u := Int{}
v := u

/* вы можете напрямую прочитать такое значение Scan */
Scan(&v)

/* вы передаёте такие переменные по ссылке */
u.Div(u, v)		// не работает
u.Div(&u, &v)	// работает
Println(&u, &v)	// выводит структуру, а не число
Println(&u, &v)	// работает
```

Всё это справедливо и для  **big.Rat**.

Указатели не выгодны по символам. Для единичных переменных пример придумать чрезвычайно трудно, хотя я не исключаю, что упускаю что-то (в своей дооолгой практике такое не встречал). Быть может, всё меняется, когда дело доходит до массивов из **big.Int**?

Нет. С массивами всё ещё хуже. Вы столкнетесть с проблемой инициализации.

```go
/* v is [5] *big.Int */
/* Элементы изначально nil и требуют инициализации */
var v [5]*Int
Println(v)			//	[<nil> <nil> <nil> <nil> <nil>]

for i := range v { v[i] = NewInt(0) }
Println(v)			//	[0 0 0 0 0]

* v is [5] big.Int */
var v [5]Int

for i := range v {
	Printf("v[%d] = %d\n", i, &v[i])
}
Println(v)
/* Вывод:
v[0] = 0
v[1] = 0
v[2] = 0
v[3] = 0
v[4] = 0
[{false []} {false []} {false []} {false []} {false []}]
*/
```

