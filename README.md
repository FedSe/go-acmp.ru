# Решения задач [acmp](https://acmp.ru/)

С адским, экстремальным сокращением во имя "лучших решений" на Go.

В качестве критерия ранжирования лучших попыток служит размер кода закачиваемой программы. При подсчете размера кода используется следующая формула:

> [Размер кода] = max([длина кода без пробелов, табуляций и символов перевода строки], [полная длина кода, делённая нацело на 4])

# Code golfing на Go по версии ACMP:

## Ограничения


- пакет обязательно называется **main**, т.к. является исполняемой программой
  
- ... поэтому основная функция тоже **main**, ведь это точка старта

- built-in функция **print()** вызывает *Presentation error*. Для чтения и записи возможно использовать пакеты **fmt** и **bufio**

Учитывая вышесказанное, самая короткая программа, которую возможно написать, выглядит следующим образом:

```go
package main
import . "fmt"
func main(){
	Print(1)
}

// 43 символа
```


Текущая версия Go **1.20.14**

С точки зрения сокращений кода, это означает отсутствие:

- built-in функций максимума/минимума -> **max()**, **min()**
- range по числу, доступны только перечисляемые типы -> **for i := range 5 {}**
- полезных функций **slices** -> **Delete()**, **Insert()**, **Clone(s)**
- для **strings** отсутствует раздел строки на первую часть и остаток -> **cut()**
- ... ну и так далее, ситуативно.

## Базовые правила

### Импорт

Импорт точечный, насколько возможно.
```go
/* ПЛОХО */
package main
import "fmt"
func main(){
	fmt.Print(1)
}

/* Хорошо */
package main
import . "fmt"
func main(){
	Print(1)
}
```
В случае golf практик это практически всегда реализуемо. Исключения:

1. совместное использование **bufio** и **fmt** - попытка такого импорта вызовет сообщение *Scanner redeclared in this block* и не скомпилируется.
2. совместное использование **strings** и **unicode** - попытка такого импорта вызовет вообще кучу сообщений - *Title, ToLower, ToTitle, ToUpper redeclared in this block*.
3. использование **reflect** через . - попытка такого импорта вызовет сообщение *Append redeclared in this block*, т.е. такой импорт принципиально невозможен.

В таком случае рекомендуется импорт с односимвольным псевдонимом.
```go
package main
import (
	b "bufio"
	. "fmt"
	. "os"
)
func main() {
	n := 0
	Fscan(b.NewReader(Stdin), &n)
	Print(n)
}
```

Пример выше демонстрирует ещё несколько очевидных правил - множественный импорт обязательно группированный (одним оператором) и с переносом строк вместо `;`

### Объявление переменных

Краткое определение `:=` выгодно часто, но не всегда. В ситуации однократного определения переменной наиболее выгодные практики таковы:

```go
myInt := 0      // int (max = int64)
myString := ""  // string
myRune := ' '   // rune
myBool := 1 > 0 // bool
myFloat := 0.   // float64
```

Но если требуется определить несколько переменных одного типа - можно считать длину с **var**. Наиболее показателен пример для int:

```go
/*11 символов*/
var a, b, c int

/*12 символов*/
a := 0
b := 0
c := 0
```
При увеличении количества требуемых **int** разрыв будет увеличиваться. Подобные вычисления запрета на использование моржи по выгоде при объявлении N переменных для всех типов следующие:

|   Тип   |    :=    |   var    | N  |
|---------|----------|----------|----|
| int     |    12    |    11    | 3  |
| string  |    17    |    16    | 4  |
| float64 |    17    |    17    | 4* |
| bool    |    10    |    10    | 2* |
| rune    |    13    |    12    | 3**|
| byte    |    10    |    8     | 1  |

	* В ситуации равенства символов лучше начать использовать var
	** Имейте в виду, что rune := ' ' это значение 32, а var rune это 0

Можно также объявить некоторые функции как переменные, содержащие ссылку на функцию (функциональное значение). Это полезно в ситуации многократного их вызова в различных участках кода или для различных данных.
```go
P := Print
P(123)		   // fmt.Print(123)

S := Scan
S(&n)		   // fmt.Scan(&n)

S := Fscan
S(s, &n)	   // fmt.Fscan(s, &n)

var b Builder
W := b.WriteByte
W(48)		   // b.WriteByte(48)

N := NewInt
a := N(1)	   // a := big.NewInt(1)

I := Index
a := I(str, sub)   // a := strings.Index(str, sub)

import (
	. "strings"
	u "unicode"
)
L = ToLower	   // strings.ToLower
U = u.ToUpper	   // unicode.ToUpper
```

### Строки

По-хорошему, `\n` в коде вообще быть не должно. Исключением здесь может быть разве что строка формата:

```go
r.ReadString('\n') // \n здесь это руна
```
Чем менять? Либо **ln**, либо raw **string literal**
```go
/*ln*/
Scanf("%d\n",&a)

Scanln(&a)

/*raw string literal*/
Printf("Число 1: %d\nЧисло 2: %d", a, b)

Printf(`Число 1: %d
Число 2: %d`, a, b) //В данном случае перенос строки учтён
```

### Карты

1. Используйте пустые интерфейсы через **any** в ключе, когда он не **int**.
2. При объявлении элементов внутри слайса, карты или иных структур, после последнего элемента запятая убирается.
```go
/*ПЛОХО*/
t := map[float64]string{
	12.5: "GREEN",
	12.9: "RED",
}

/*Хорошо*/
t := map[any]string{
	12.5: "GREEN",
	12.9: "RED"}
```
3. Нет ситуаций, когда **make** выгоден для **map**. Не используйте его.
```go
/*ПЛОХО*/
var h = make(map[any]int)
h := make(map[any]int)
var v = make(map[any][]string)

/*Хорошо*/
var h = map[any]int{}
h := map[any]int{}
var v = map[any][]string{}
```
4. Поиск по карте, если без булевой о ненаходе никак - только с переносом строки во избежание `;`
```go
v, o := m[x]
if o {
	return v
}
```

### Switch-case

Выгоден для множественных сравнений с единым результатом:
```go
/*28 символов*/
if x == f || x == -f || y == f || y == -f { ... }

/*23 символа*/
switch f {
	case x, -x, y, -y: ...
}
```

## math/big

Всегда стоит смотреть на сигнатуры функций *math/big*. Это позволяет делать сложные однострочные конструкции. При выборе способа инициализации структуры следует исходить их дальнейшего применения. Технически есть два варианта - указатель или структура, но фактически только структура, и вот почему:

### u - Указатель на структуру, *big.Int
```go
/* u это *big.Int */
u := new(Int)	// 11 - плохо
u := &Int{}	//  9 - возможно
u := NewInt(0)	// 12 - возможно
var u *Int	//  8 - бессмысленно(не инициализировано)
```
Использование:
```go
/* вы не можете сделать новый *Int на основе текущего */
u := NewInt(0)
u2 := u		// Это не работает так
u2 := NewInt(0)	// Это работает так

/* вы не можете напрямую прочитать такое значение Scan */
var u *Int
Scan(&u)

/* вы передаёте такие переменные как есть */
var u, v *Int
v = NewInt(999)
u = NewInt(999)
u.Div(u, v)
```
### u - Структура, big.Int
```go
/* u это big.Int */
u := Int{}	// 8 - плохо
var u Int	// 7 - хорошо
```
Использование:
```go
/* вы можете сделать новый *Int на основе текущего */
u := Int{}
u2 := u

/* вы можете напрямую прочитать такое значение Scan */
var u Int
Scan(&u)

/* вы передаёте такие переменные по ссылке */
u.Div(u, v)	// не работает
u.Div(&u, &v)	// работает
Println(&u, v)	// выводит структуру, а не число
Println(&u, &v)	// работает
```

Всё это справедливо и для  **big.Rat**.

Указатели не выгодны по символам. Для единичных переменных пример придумать чрезвычайно трудно, хотя я не исключаю, что упускаю что-то (в своей дооолгой практике такое не встречал). Быть может, всё меняется, когда дело доходит до массивов из **big.Int**?

Нет. С массивами всё ещё хуже. Вы столкнетесть с проблемой инициализации.

```go
/* v это [5] *big.Int */
/* Элементы изначально nil и требуют инициализации */
var v [5]*Int
Println(v)	//	[<nil> <nil> <nil> <nil> <nil>]

for i := range v { v[i] = NewInt(0) }
Println(v)	//	[0 0 0 0 0]

/* v это [5] big.Int */
/* Элементы изначально "равны нулю" */
var v [5]Int

for i := range v {
	Printf("v[%d] = %d\n", i, &v[i])
}
Println(v)
/* Вывод:
v[0] = 0
v[1] = 0
v[2] = 0
v[3] = 0
v[4] = 0
[{false []} {false []} {false []} {false []} {false []}]
*/
```

## bufio

Пакет требует много символов на себя, неизбежно требует импорт **os** пакета, но имеет 3 ситуации для применения:

1. Ускорение вывода
2. Чтение строк с пробелом
3. Ускорение ввода

Эти вещи бывают в задачах безальтернативны к применению **bufio**. Рассмотрим эти ситуации.

### 1. Ускорение вывода

В любой статье, в любых примерах по **bufio** вы увидите стандартные 4 варианта:
- Write(): записывает срез байтов
- WriteByte(): записывает один байт
- WriteRune(): записывает один объект типа rune
- WriteString(): записывает строку

К такому перечню вопрос - где тут записывать **int**? **float64**? В общем, я рекомендую игнорировать эти варианты вывода и использовать всегда один универсальный:

```go
func main() {
	s := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	w := b.NewWriter(Stdout)
	Fprint(w, "Числа --")
	for _, v := range s {
		Fprint(w, " ", v)  // Поддерживает множественный ввод
	}
	Fprintf(w, "%c", '.')	   // Поддерживает форматирование
	w.Flush()		   // Обязательная строка для вывода
}
// Вывод: Числа -- 1 2 3 4 5 6 7 8 9 10.
```

Возможна крайне редкая ситуация, где нужен **WriteByte()**. Его ключевая особенность - сохранять байт как часть последовательности. **Print()** интерпретирует один байт как символ, что даёт невалидную последовательность, и Go заменяет её на ``. Используется в ситуациях, когда нет возможности проитерироваться по строке, а условия задачи позволяют потратить время на преобразование строк в массивы рун, или где такой подход может не работать в задачах на кодировки.

### 2 и 3. Ускорение ввода/ввод полных строк

Есть два пути: **NewReader(Stdin)** и **NewScanner(Stdin)**

* Reader()
```go
var n string
r := b.NewReader(Stdin)
    
Fscan(r, &n)		  // Ввод: "Одна строка"
Print(n)		  // Вывод: "Одна"
    
n, _ = r.ReadString('\n') // Ввод: "Одна строка"
Print(n)		  // Вывод: "Одна строка"
```

* Scanner()
```go
var n string
r := b.NewScanner(Stdin)
    
r.Scan()		// Ввод: "Одна строка"
n = r.Text()
    
Print(n)		// Вывод: "Одна строка"
    
r.Split(b.ScanWords)	// Режим чтения пословно
r.Scan()		// Ввод: "Одна строка"
n = r.Text()

Print(n)		// Вывод: "Одна"
```

**Fscan** можно объявить как `S := Fscan` и вызывать `S(r, &n)`. Казалось бы, судя по символам, **Reader** должен быть использован, когда читаются большие данные чисел, а **Scanner**, когда нам важна исходная строка со всеми её пробелами. Реальная картина примерно такая, но дело в том, что <u>Fscan медленный</u>. Он значительно быстрее **Scan**, но в некоторых задачах этого не достаточно. Чтобы вы понимали, насколько - иной раз выгоднее вызвать для каждого из сотни тысяч прочитанного через **Scanner Split-ScanWords** "числа" функцию `Atoi`, чтобы сделать из него настоящее число, чем читать сразу число.

Использовать **bufio** можно также потому, что **Scan()** на больших данных не выгоден по памяти. Кстати, `scanner.Scan()` как правило уделывает `Fscan(reader, ...)` на больших данных и проигрывает на малых, но тут дело больше в самих интерфейсах и их работе с буфером. На практике это не важно и самого использования **bufio** достаточно.

И ещё одна деталь - обработка переносов. **Scanner** автоматически отрезает от строки `\n`, `\r\n`. **Reader** не имеет такого поведения по умолчанию.

## container/heap

Работа с пакетом требует реализовать `heap.Interface` для вашего типа. У вас должен быть тип, соответствующий
```go
type Interface interface {
	sort.Interface
	Push(x any)
	Pop() any
}
/*sort.Interface*/
type Interface interface {
	Len() int
	Less(i, j int) bool
	Swap(i, j int)
}
```
Причем **heap** использует функции неявно, т.е. если вы пишете в теле `Swap()` пустую строку, так как сами её не используете - вы ломаете всё, так как ей пользуется `up()`, которым пользуется `Push()`, которым пользуетесь вы. Можно писать свою реализацию пакета, но она будет символов на 100 длиннее, чем его прямое использование. Так что рекомендации общие - не тратьте время, чтобы выдумать что-то ещё. Я уже потратил. Это обречено и проклято.

Можно отобрать у пакета функции и убрать его при условии, что решение проходит с пустым `Swap`. Это означает, что код работает корректно и как стек, а не только как куча. Тогда действительно экономия.

