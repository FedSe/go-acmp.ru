# Решения задач [acmp](https://acmp.ru/)

С адским, экстремальным сокращением во имя "лучших решений" на Go.

В качестве критерия ранжирования лучших попыток служит размер кода закачиваемой программы. При подсчете размера кода используется следующая формула:

> [Размер кода] = max([длина кода без пробелов, табуляций и символов перевода строки], [полная длина кода, делённая нацело на 4])

# Code golfing на Go в версии ACMP:

## Ограничения


- пакет обязательно называется **main**
  
- ... поэтому основная функция тоже **main**

- built-in функция **print()** вызывает *Presentation error*. Для чтения и записи возможно использовать пакеты **fmt** и **bufio**

Учитывая вышесказанное, самая короткая программа, которую возможно написать, выглядит следующим образом:

```go
package main
import . "fmt"
func main(){
	Print(1)
}

// 43 символа
```


Текущая версия Go **1.20.14**

С точки зрения сокращений кода, это означает отсутствие:

- built-in функций максимума/минимума -> **max()**, **min()**
- range по числу, доступны только перечисляемые типы -> **for i := range 5 {}**
- полезных функций **slices** -> **Delete()**, **Insert()**, **Clone(s)**
- для **strings** отсутствует раздел строки на первую часть и остаток -> **cut()**
- ... ну и так далее, ситуативно.

## Правила

### Импорт

Импорт точечный, насколько возможно.
```go
/* ПЛОХО */
package main
import "fmt"
func main(){
	fmt.Print(1)
}

/* Хорошо */
package main
import . "fmt"
func main(){
	Print(1)
}
```
В случае golf практик это практически всегда реализуемо. Исключения:

1. совместное использование **bufio** и **fmt** - попытка такого импорта вызовет сообщение *Scanner redeclared in this block* и не скомпилируется.
2. совместное использование **strings** и **unicode** - попытка такого импорта вызовет вообще кучу сообщений - *Title, ToLower, ToTitle, ToUpper redeclared in this block*.
3. использование **reflect** через . - попытка такого импорта вызовет сообщение *Append redeclared in this block*, т.е. такой импорт принципиально невозможен.

В таком случае рекомендуется импорт с односимвольным псевдонимом.
```go
package main
import (
	b "bufio"
	. "fmt"
	. "os"
)
func main() {
	n := 0
	Fscan(b.NewReader(Stdin), &n)
	Print(n)
}
```

Пример выше демонстрирует ещё несколько очевидных правил - множественный импорт обязательно группированный (одним оператором) и с переносом строк вместо **;**.

### Объявление переменных

Краткое определение **:=** выгодно часто, но не всегда. В ситуации однократного определения переменной наиболее выгодные практики таковы:

```go
myInt := 0      // int (max = int64)
myString := ""  // string
myRune := ' '   // rune
myBool := 1 > 0 // bool
myFloat := 0.   // float64
```

Но если требуется определить несколько переменных одного типа - можно считать длину с **var**. Наиболее показателен пример для int:

```go
/*11 символов*/
var a, b, c int

/*12 символов*/
a := 0
b := 0
c := 0
```
При увеличении количества требуемых **int** разрыв будет увеличиваться. Подобные вычисления запрета на использование моржи по выгоде при объявлении N переменных для всех типов следующие:

|   Тип   |    :=    |   var    | N |
|---------|----------|----------|---|
| int     |    12    |    11    | 3 |
| string  |    17    |    16    | 4 |
| float64 |    17    |    17    | 4* |
|   bool  |    10    |    10    | 2* |
|   rune  |    13    |    12    | 3**|
|   byte  |    10    |    8     | 1  |

	* В ситуации равенства символов лучше начать использовать var
	** Имейте в виду, что rune := ' ' это значение 32, а var rune это 0

Можно также объявить некоторые функции как переменные, содержащие ссылку на функцию (функциональное значение). Это полезно в ситуации многократного их вызова в различных участках кода или для различных данных.
```go
P := Print
P(123)	//	fmt.Print(123)

S := Scan
S(&n)	//	fmt.Scan(&n)

S := Fscan
S(s, &n)	//	fmt.Fscan(s, &n)

var b Builder
W := b.WriteByte
W(48)	//	b.WriteByte(48)

N := NewInt
a := N(1)	//	a := big.NewInt(1)

I := Index
a := I(str, sub)	// a := strings.Index(str, sub)

import (
	. "strings"
	u "unicode"
)
L = ToLower	// strings.ToLower
U = u.ToUpper	// unicode.ToUpper
```

### Строки

По хорошему, "\n" в коде вообще быть не должно. Исключением здесь может быть разве что строка формата:

```go
r.ReadString('\n') // \n здесь это руна
```
Чем менять? Либо **ln**, либо raw **string literal**
```go
/*ln*/
Scanf("%d\n",&a)

Scanln(&a)

/*raw string literal*/
Printf("Число 1: %d\nЧисло 2: %d", a, b)

Printf(`Число 1: %d
Число 2: %d`, a, b) //В данном случае перенос строки учтён
```

...