# Решения задач [acmp](https://acmp.ru/)

С адским, экстремальным сокращением во имя "лучших решений" на Go.

В качестве критерия ранжирования лучших попыток служит размер кода закачиваемой программы. При подсчете размера кода используется следующая формула:

> [Размер кода] = max([длина кода без пробелов, табуляций и символов перевода строки], [полная длина кода, делённая нацело на 4])

# Code golfing на Go по версии ACMP:

## Ограничения


- пакет обязательно называется **main**, т.к. является исполняемой программой
  
- ... поэтому основная функция тоже **main**, ведь это точка старта

- built-in функция **print()** вызывает *Presentation error*. Для чтения и записи возможно использовать пакеты **fmt** и **bufio**

Учитывая вышесказанное, самая короткая программа, которую возможно написать, выглядит следующим образом:

```go
package main
import . "fmt"
func main(){
	Print(1)
}

// 43 символа
```


Текущая версия Go **1.20.14**

С точки зрения сокращений кода, это означает отсутствие:

- built-in функций максимума/минимума -> **max()**, **min()**
- range по числу, доступны только перечисляемые типы -> **for i := range 5 {}**
- полезных функций **slices** -> **Delete()**, **Insert()**, **Clone(s)**
- для **strings** отсутствует раздел строки на первую часть и остаток -> **cut()**
- ... ну и так далее, ситуативно.

## Базовые правила

### Импорт

Импорт точечный, насколько возможно.
```go
/* ПЛОХО */
package main
import "fmt"
func main(){
	fmt.Print(1)
}

/* Хорошо */
package main
import . "fmt"
func main(){
	Print(1)
}
```
В случае golf-практик это практически всегда реализуемо. Исключения:

1. совместное использование `bufio` и `fmt` - попытка такого импорта вызовет сообщение *Scanner redeclared in this block* и не скомпилируется.
2. совместное использование `strings` и `unicode` - попытка такого импорта вызовет вообще кучу сообщений - *Title, ToLower, ToTitle, ToUpper redeclared in this block*.
3. использование `reflect` через . - попытка такого импорта вызовет сообщение *Append redeclared in this block*, т.е. такой импорт принципиально невозможен.
4. совместное использование `io` и `os` - попытка такого импорта вызовет сообщение *Pipe redeclared in this block* и не скомпилируется.

В таком случае рекомендуется импорт с односимвольным псевдонимом.
```go
package main
import (
	b "bufio"
	. "fmt"
	. "os"
)
func main() {
	n := 0
	Fscan(b.NewReader(Stdin), &n)
	Print(n)
}
```

Пример выше демонстрирует ещё несколько очевидных правил - множественный импорт обязательно группированный (одним оператором) и с переносом строк вместо `;`

### Объявление переменных

**Краткое определение `:=` выгодно часто, но не всегда**. В ситуации однократного определения переменной наиболее выгодные практики таковы:

```go
myInt := 0      // int (max = int64)
myString := ""  // string
myRune := ' '   // rune
myBool := 1 > 0 // bool
myFloat := 0.   // float64
```

Но если требуется определить несколько переменных одного типа - **нужно считать длину с `var`**. Наиболее показателен пример для int:

```go
/*11 символов*/
var a, b, c int

/*12 символов*/
a := 0
b := 0
c := 0
```
При увеличении количества требуемых **int** разрыв будет увеличиваться. Подобные вычисления запрета на использование моржи по выгоде при объявлении N переменных для всех типов следующие:

|   Тип   |    :=    |   var    | N  |
|---------|----------|----------|----|
| int     |    12    |    11    | 3  |
| string  |    17    |    16    | 4  |
| float64 |    17    |    17    | 4* |
| bool    |    10    |    10    | 2* |
| rune    |    13    |    12    | 3**|
| byte    |    10    |    8     | 1  |

	* В ситуации равенства символов лучше начать использовать var
	** Имейте в виду, что rune := ' ' это значение 32, а var rune это 0

Можно также объявить некоторые **функции как переменные**, содержащие ссылку на функцию (функциональное значение). Это полезно в ситуации многократного их вызова в различных участках кода или для различных данных.
```go
P := Print
P(123)             // fmt.Print(123)

S := Scan
S(&n)              // fmt.Scan(&n)

S := Fscan
S(s, &n)           // fmt.Fscan(s, &n)

var b Builder
W := b.WriteByte
W(48)              // b.WriteByte(48)

N := NewInt
a := N(1)          // a := big.NewInt(1)

I := Index
a := I(str, sub)   // a := strings.Index(str, sub)

import (
	. "strings"
	u "unicode"
)
L = ToLower        // strings.ToLower
U = u.ToUpper      // unicode.ToUpper
```

Можно использовать **анонимные функции**, когда применение функций неизбежно. Это позволяет сохранить контекст, не передавая его нативно во внешнюю функцию - экономия очевидна.

```go
func main() {
	var a [10]int
	F := func(r, c int) {	// a[10]int в том же пространстве имён
		for i := range a[:c] {
			a[i] += r
		}
	}
	F(2, 5) ; F(7, 3) ; F(1, 9)
	F(3, 6) ; F(5, 2) ; F(17, 4)
	Print(a)   // [35 35 30 23 6 4 1 1 1 0]
}
```

Помните - анонимка всего на 2 символа дороже аналогичной обычной функции.


**Экспоненциальные записи чисел**. Пользование обязательно. Всё, что вам нужно знать:
```go
var a [2e5]int   // var a [200000]int

t := 1000000000  // int, 13 симв.
t := 1e9         // float64, 6 симв.
t := int(1e9)    // int, 11 симв.
const t = 1e9    // что угодно, 10 симв.

Printf("%f", 1e-6)      // 0.000001

var A int
A = 1e9
B := 1e9
Printf("%T, %T", A, B)  // int, float64
```
В ситуации, если нужно большое int число, можно использовать **битовые сдвиги**.
```go
t := 1000000000  // int, 13 симв. - Очень плохо
t := int(1e9)    // int, 11 симв. - Плохо
var t int = 1e9  // int, 8 симв. - Хорошо, если var уже есть
m := 0           //
m = 1e9          // int, 9 симв. - Хорошо, если var нет
t := 1 << 30     // int, 8 симв. = 1 * 2^30 = 1 073 741 824 - Лучшее, когда возможное
```

**Псевдонимы(Алиасы)** и **Определения типов** бывают выгодны.
Напоминаю, что выглядят они одинаково, как объявление `type` с конкретным типом.
В случае Алиаса - через знак равенства, что, очевидно, длиннее на символ.
```go
/* в данном случае используется Алиас "A",
   т.к. пакет math не работает с типом "A" */
import . "math"
type A = float64   // Алиас к float64
var x, y, a, b A
func F(a, b A) A {
	return Abs(a*(y-b)-(x-a)*b) / Sqrt(a*a+b*b)
}
// Трижды float64 (21 симв.)
// type A = float64 A A A (16 симв.)
```
Go устроен так, что размерность массива является частью его типа, а не хранимой переменной
```go
func main() {
...
d := [4e3]float64{1}
Scan(&N, &Q)
for 0 < N {
	var w [4e3]float64
...

/* Можно сократить так */

type A [4e3]float64 // новый тип
func main() {
...
d := A{1}
Scan(&N, &Q)
for 0 < N {
	var w A
...
```

В качестве типа могут использоваться также слайсы и карты.

### Строки

По-хорошему, `\n` в коде вообще быть не должно. Здесь может быть два исключения:
```go
/* Исключение 1: '\n' как руна */
r := bufio.NewReader(Stdin)
r.ReadString('\n')

/* Исключение 2: CRLF формат переносов */
s1 := "Строка1"
s2 := "Строка2"
fmt.Print(s1,"\r\n", s2)
// Требуется, если чекер на задаче реально ждёт 1310 в конце строк
// В Go при любом классическом варианте перенос это 10 - \n.
```
Чем менять в остальных случаях? Либо **ln**, либо raw **string literal**
```go
/*ln*/
Scanf("%d\n",&a)

Scanln(&a)

/*raw string literal*/
Printf("Число 1: %d\nЧисло 2: %d", a, b)

Printf(`Число 1: %d
Число 2: %d`, a, b) // В данном случае перенос строки учтён
```

### Карты

1. Используйте пустые интерфейсы через `any` в ключе, когда он не `int`.
2. При объявлении элементов внутри слайса, карты или иных структур, после последнего элемента запятая убирается.
```go
/*ПЛОХО*/
t := map[float64]string{
	12.5: "GREEN",
	12.9: "RED",
}

/*Хорошо*/
t := map[any]string{
	12.5: "GREEN",
	12.9: "RED"}
```
3. Нет ситуаций, когда `make()` выгоден для `map`. Не используйте его.
```go
/*ПЛОХО*/
var h = make(map[any]int)
h := make(map[any]int)
var v = make(map[any][]string)
w := make(map[any]map[int]bool)

/*Хорошо*/
var h = map[any]int{}
h := map[any]int{}
var v = map[any][]string{}
w := map[any]map[int]bool{}
```
4. Поиск по карте, если без булевой о ненаходе никак - только с переносом строки во избежание `;`
```go
v, o := m[x]
if o {
	return v
}
```

### Switch-case

Выгоден для множественных сравнений с единым результатом:
```go
/*28 символов*/
if x == f || x == -f || y == f || y == -f { ... }

/*23 символа*/
switch f {
	case x, -x, y, -y: ...
}
```

## math/big

Всегда стоит смотреть на сигнатуры функций *math/big*. Это позволяет делать сложные однострочные конструкции. При выборе способа инициализации структуры следует исходить их дальнейшего применения. Технически есть два варианта - указатель или структура, но как правило структура, и вот почему:

### u - Указатель на структуру, *big.Int
```go
/* u это *big.Int */
u := new(Int)   // 11 - плохо
u := &Int{}     //  9 - возможно
u := NewInt(0)  // 12 - возможно
var u *Int      //  8 - бессмысленно(не инициализировано)
```
Использование:
```go
/* вы не можете сделать новый *Int на основе текущего */
u := NewInt(0)
u2 := u         // Это не работает так
u2 := NewInt(0) // Это работает так

/* вы не можете напрямую прочитать такое значение Scan */
var u *Int
Scan(&u)

/* вы передаёте такие переменные как есть */
var u, v *Int
v = NewInt(999)
u = NewInt(999)
u.Div(u, v)
```
### u - Структура, big.Int
```go
/* u это big.Int */
u := Int{}	// 8 - плохо
var u Int	// 7 - хорошо
```
Использование:
```go
/* вы можете сделать новый *Int на основе текущего */
u := Int{}
u2 := u

/* вы можете напрямую прочитать такое значение Scan */
var u Int
Scan(&u)

/* вы передаёте такие переменные по ссылке */
u.Div(u, v)     // не работает
u.Div(&u, &v)   // работает
Print(&u, v)    // выводит структуру, а не число
Print(&u, &v)   // работает
```

Всё это справедливо и для  **big.Rat**.

Указатели не выгодны по символам. Быть может, всё меняется, когда дело доходит до массивов из **big.Int**?

Нет. С массивами всё ещё хуже. Вы столкнетесть с проблемой инициализации.

```go
/* v это [5] *big.Int */
/* Элементы изначально nil и требуют инициализации */
var v [5]*Int
Println(v)	//	[<nil> <nil> <nil> <nil> <nil>]

for i := range v { v[i] = NewInt(0) }
Println(v)	//	[0 0 0 0 0]

/* v это [5] big.Int */
/* Элементы изначально "равны нулю" */
var v [5]Int

for i := range v {
	Printf("v[%d] = %d\n", i, &v[i])
}
Println(v)
/* Вывод:
v[0] = 0
v[1] = 0
v[2] = 0
v[3] = 0
v[4] = 0
[{false []} {false []} {false []} {false []} {false []}]
*/
```

Зачем указатели вообще нужны в таком случае? Для **Int**, заранее определяемых значениями! Вот все варианты определения таких переменных:
```go
a := NewInt(42)
b, _ := new(Int).SetString("42", 10)
c := new(Int).SetInt64(42)
d := new(Int).SetUint64(42)
e := new(Int).SetBytes([]byte{42})
// ... и просто арифметикой
```
**NewInt()** наглядно безальтернативна.

## bufio

Пакет требует много символов на себя, неизбежно требует импорт **os** пакета, но имеет 3 ситуации для применения:

1. Ускорение вывода
2. Чтение строк с пробелом
3. Ускорение ввода

Эти вещи бывают в задачах безальтернативны к применению **bufio**. Рассмотрим эти ситуации.

### 1. Ускорение вывода

В любой статье, в любых примерах по **bufio** вы увидите стандартные 4 варианта:
- Write(): записывает срез байтов
- WriteByte(): записывает один байт
- WriteRune(): записывает один объект типа rune
- WriteString(): записывает строку

К такому перечню вопрос - где тут записывать **int**? **float64**? В общем, я рекомендую игнорировать эти варианты вывода и использовать всегда один универсальный:

```go
func main() {
	s := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	w := b.NewWriter(Stdout)
	Fprint(w, "Числа --")
	for _, v := range s {
		Fprint(w, " ", v)  // Поддерживает множественный ввод
	}
	Fprintf(w, "%c", '.')      // Поддерживает форматирование
	w.Flush()                  // Обязательная строка для вывода
}
// Вывод: Числа -- 1 2 3 4 5 6 7 8 9 10.
```

Возможна крайне редкая ситуация, где нужен `WriteByte()`. Его ключевая особенность - сохранять байт как часть последовательности. `Print()` интерпретирует один байт как символ, что даёт невалидную последовательность, и Go заменяет её на ``. Используется в ситуациях, когда нет возможности проитерироваться по строке, а условия задачи позволяют потратить время на преобразование строк в массивы рун, или где такой подход может не работать в задачах на кодировки.

### 2 и 3. Ускорение ввода/ввод полных строк

Есть два пути: **`NewReader(Stdin)` и `NewScanner(Stdin)`**

* Reader()
```go
var n string
r := b.NewReader(Stdin)
    
Fscan(r, &n)              // Ввод: "Одна строка"
Print(n)                  // Вывод: "Одна"
    
n, _ = r.ReadString('\n') // Ввод: "Одна строка"
Print(n)                  // Вывод: "Одна строка"
```

* Scanner()
```go
var n string
r := b.NewScanner(Stdin)
    
r.Scan()                // Ввод: "Одна строка"
n = r.Text()
    
Print(n)                // Вывод: "Одна строка"
    
r.Split(b.ScanWords)    // Режим чтения пословно
r.Scan()                // Ввод: "Одна строка"
n = r.Text()

Print(n)                // Вывод: "Одна"
```

**Fscan** можно объявить как `S := Fscan` и вызывать `S(r, &n)`. Казалось бы, судя по символам, **Reader** должен быть использован, когда читаются большие данные чисел, а **Scanner**, когда нам важна исходная строка со всеми её пробелами. Реальная картина примерно такая, но дело в том, что **Fscan() медленная**. Она значительно быстрее **Scan()**, но в некоторых задачах этого не достаточно. Чтобы вы понимали, насколько - иной раз выгоднее вызвать для каждого из сотни тысяч прочитанного через **Scanner Split-ScanWords** "числа" функцию `Atoi()`, чтобы сделать из него настоящее число, чем читать сразу число.

Использовать **bufio** можно также потому, что `Scan()` на больших данных не выгодна по памяти. Кстати, `scanner.Scan()` как правило уделывает `Fscan(reader, ...)` на больших данных и проигрывает на малых, но тут дело больше в самих интерфейсах и их работе с буфером. На практике редко важно и самого использования **bufio** достаточно. Исключение - грандиозно огромная строка на входе, которая буквально не помещается в буфер, при этом программа никак вам этого не покажет. Пробуйте вручную задать буфер для **Scanner** через конструкцию типа `s.Buffer(make([]byte, 4096), 2e6)` - это самый короткий и выгодный по памяти путь.

И ещё одна деталь - обработка переносов. **Scanner** автоматически отрезает от строки `\n`, `\r\n`. **Reader** не имеет такого поведения по умолчанию.

## container/heap

Работа с пакетом требует реализовать `heap.Interface` для вашего типа. У вас должен быть тип, соответствующий
```go
type Interface interface {
	sort.Interface
	Push(x any)
	Pop() any
}
/*sort.Interface*/
type Interface interface {
	Len() int
	Less(i, j int) bool
	Swap(i, j int)
}
```
Причем **heap** использует функции неявно, т.е. если вы пишете в теле `Swap()` пустую строку, так как сами её не используете - вы ломаете всё, так как ей пользуется `up()`, которым пользуется `Push()`, которым пользуетесь вы. Можно писать свою реализацию пакета, но она будет символов на 100 длиннее, чем его прямое использование. Так что рекомендации общие - не тратьте время, чтобы выдумать что-то ещё. Я уже потратил. Это обречено и проклято.

Можно отобрать у пакета функции и убрать его при условии, что решение проходит с пустым `Swap`. Это означает, что код работает корректно и как стек, а не только как куча. Тогда действительно экономия.

Не пользуйтесь `h.Len()`. Пользуйтесь `len(h)`.

Не пользуйтесь `heap.Init(h)`. Пользуйтесь `var h H` (H - ваш тип, реализующий heap).

## strconv

* `Atoi()` - Конвертация строки в число. Наиболее часто встречаемая в коде функция из пакета. Причина проста - менять нечем

```go
// самостоятельная реализация побыстрее - 32 символа в лучшем сценарии
for _, c := range s {
    n = n*10 + int(c-48)   // допустим, пустая n у нас уже есть
}

// либо медленная, но лаконичная
Sscan(s, &f)               // 11 символов

// реализация с импорта - 24 символа в худшем сценарии
( . "strconv" )            // допустим, кроме fmt не было ничего, тогда +2 скобки
n, _ := Atoi(s) 
```
`Sscan()` медленный настолько, что его применение возможно слишком редко.


* `Itoa()` - Конвертация числа в строку. Ни в одном из golf-решений не встречается. Причина проста - есть, чем менять. Даже учитывая, что `Sprint()` медленнее
```go
// самостоятельная реализация - 12 символов
s := Sprint(n)

// реализация из пакета - сама строка те же 12 символов
( . "strconv" )            // +12 на импорт
s, _ := Itoa(n)
```

## math

Для выражения `Sqrt(a*a+b*b)` есть отдельная функция `Hypot(a, b)`
